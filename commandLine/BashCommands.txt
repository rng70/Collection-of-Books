List of Commands for bash-terminal :

	The command line is a text interface for your computer. It’s a program that takes in commands, which it passes on to the computer’s 
	operating system to run.From the command line, you can navigate through files and folders on your computer, just as you would with
	Windows Explorer on Windows or Finder on Mac OS. The difference is that the command line is fully text-based.

	Here’s an appendix of commonly used commands.

	All commands for every terminal are case sensitive. 
	Bash terminal will be ready to execute any command when $ symbol appear. This means that the terminal is ready to execute command.
	So, $ is called 'shell prompt'.

	Command:
		1. ls --> 
			'ls' is a command for printing all directories ( folders ) and files of the current working directory.
			If current working directory is ../dictionaries/Mine and that folder contains three file 
					1. test.cpp
					2. note.txt
					3. foldertozip.dll
			then 'ls' command will print all the filenames in console.

		2. cd -->
			'cd' stands for change directory. If current working directory is  ../dictionaries/Mine and cd command is executed like below
			../dictionaries/Mine> 
			$ cd .. 
		Then the working directory will be ..dictionaries/   . Here '..' will change the current working directory such a way that changed working directory 
		will be exactly earlier directory of the present one.
		If the current working directory is '/E/now/Blogs/' and 'cd D:' command is executed then current directory will be '/D/'
		
		3. pwd -->
			'pwd' stands for 'Print Working Directory'. It will print the current working directory. This is a strong command as for large filesystem
			it is very common to forget or lose the current working directory. To know the current directory name this command is executed.

		4. mkdir -->
			'mkdir' is stands for 'make directory'. To make a directory under the current working directory mkdir is executed.
			this command takes a argument as the argument will be the name of the new directory (folder)	
			If current working directory is ../dictionaries/Mine and that folder contains three file 
					1. test.cpp
					2. note.txt
					3. foldertozip.dll
			then after executing the following command

			$ mkdir MyFolder		--# Here MyFolder is argument as mentioned before #--
			$ ls		
				1. test.cpp
				2. note.txt
				3. foldertozip.dll
				4. MyFolder	
			will be shown on console.

		5. touch -->
			'touch' is almost similar as 'mkdir' but unlike 'mkdir' it will make a file not a directory. It will also take argument and make a file named as 
			given argument. To remember that if file extension is not given then by default it will be a system file that can be renamed later.
			If current working directory is ../dictionaries/Mine and that folder contains three file 
					1. test.cpp
					2. note.txt
					3. foldertozip.dll
			then after executing the following command
			
			$ touch new.txt
			$ ls
				1. test.cpp
				2. note.txt
				3. foldertozip.dll
				4. new.txt	
			will be shown on console.
		
			If the file exists, touch is used to update the modification time of the file.

		6. uniq  -->
			'uniq' short for “unique”, takes a filename or standard input and prints out every line, removing any exact duplicates.
			
			$ uniq no_duplicate.txt

		7. " > " -->
			'>' takes the standard output of the command on the left, and redirects it to the file on the right.
			
			$ cat oceans.txt > continents.txt

		8. " >> " -->
			$ cat glaciers.txt >> rivers.txt
			
			'>>' takes the standard output of the command on the left and appends (adds) it to the file on the right.

		9. " < " -->	
			$ cat < lakes.txt

			'<'  takes the standard input from the file on the right and inputs it into the program on the left.

		10. ' | ' -->
			$ cat volcanoes.txt | wc
			| is a “pipe”. The | takes the standard output of the command on the left, and pipes it as standard input to the command on the right. 
			You can think of this as “command to command” redirection.

		11. ' ~/.bash_profile ' -->
			$ nano ~/.bash_profile

			'~/.bash_profile' is the name of file used to store environment settings. It is commonly called the “bash profile”. When a session starts, 
			it will load the contents of the bash profile before executing commands.

		12. alias -->
			$ alias pd="pwd"

			The alias command allows you to create keyboard shortcuts, or aliases, for commonly used commands.

		13.  cp -->
			$ cp ada_lovelace.txt historical/

			cp copies files or directories. Here, we copy the file ada_lovelace.txt and place it in the historical/ directory

		14. wildcard (*) -->
			$ cp * satire/

     			The wildcard * selects all of the files in the current directory. The above example will copy all of the files in the current directory to the 
			directory called satire. There are other types of wildcards, too, which are beyond the scope of this glossary.

 			$ cp m*.txt scifi/

			Here, m*.txt selects all files in the working directory starting with “m” and ending with “.txt”, and copies them to scifi/.

		15. env -->
			$ env
			The env command stands for “environment”, and returns a list of the environment variables for the current user.
		
		16. env | grep VARIABLE -->
			$ env | grep PATH
			
			env | grep PATH is a command that displays the value of a single environment variable.

		17. export -->
			$ export USER="Jane Doe"
		
			'export' makes the variable to be available to all child sessions initiated from the session you are in. This is a way to make the variable persist 
			across programs.

		18. grep -->
			$ grep "Mount" mountains.txt
			'grep' stands for “global regular expression print”. It searches files for lines that match a pattern and returns the results. It is case sensitive.

		19. grep -I -->
			$ grep -i "Mount" mountains.txt

			grep -i enables the command to be case insensitive.

		20. grep -R --.
			$ grep -R Arctic /home/ccuser/workspace/geography

			'grep -R' searches all files in a directory and outputs filenames and lines containing matched results. -R stands for “recursive”.

		21. grep -RL -->
			$ grep -Rl Arctic /home/ccuser/workspace/geography
			'grep -Rl' searches all files in a directory and outputs only filenames with matched results. -R stands for “recursive” and l stands for “files with matches”.

		22. HOME -->
			$ echo $HOME

			The HOME variable is an environment variable that displays the path of the home directory.
	
		23. ls -a -->
			$ ls -a

			output : .  ..  .preferences  action  drama comedy  genres.xt

			' ls -a ' lists all contents in the working directory, including hidden files and directories starting with (.) and are not shown during 'ls' command.

			The -a is called an option. Options modify the behavior of commands. Here we used ls -a to display the contents of the working directory in more detail.

		24. ls -l -->
			$ ls -l

			' ls -l ' lists all contents of a directory in long format

			output: 
				table 12
				drwxr-xr-x 5  cc  eng  4096 Jun 24 16:51  action
				drwxr-xr-x 4  cc  eng  4096 Jun 24 16:51  comedy
				drwxr-xr-x 6  cc  eng  4096 Jun 24 16:51  drama
				-rw-r--r-- 1  cc  eng     0 Jun 24 16:51  genres.txt

					The -l option lists files and directories as a table. Here there are four rows, with seven columns separated by spaces. Here’s what each column means:

						1. Access rights. These are actions that are permitted on a file or directory.
						
						2. Number of hard links. This number counts the number of child directories and files. This number includes the parent directory link (..) and 
						    current directory link (.).

						3. The username of the file’s owner. Here the username is cc.

						4. The name of the group that owns the file. Here the group name is eng.

						5. The size of the file in bytes.

						6. The date & time that the file was last modified.
 
						7. The name of the file or directory.

		25. ls -t -->
			' ls -t ' orders files and directories by the time they were last modified.

		26. ls -alt
			$ ls -alt

					drwxr-xr-x 4 cc eng 4096 Jun 29 12:22 .
					-rw-r--r-- 1 cc eng    0 Jun 29 12:22 .gitignore
					drwxr-xr-x 5 cc eng 4096 Jun 30 14:20 ..
					drwxr-xr-x 2 cc eng 4096 Jun 29 12:22 satire
					drwxr-xr-x 2 cc eng 4096 Jun 29 12:22 slapstick
					-rw-r--r-- 1 cc eng   14 Jun 29 12:22 the-office.txt 
			
			The -t option orders files and directories by the time they were last modified.

			In addition to using each option separately, like ls -a or ls -l, multiple options can be used together, like ls -alt.

			Here, ls -alt lists all contents, including hidden files and directories, in long format, ordered by the date and time they were last modified.

		27. mv -->
			$ mv superman.txt superhero/

			To move a file into a directory, use mv with the source file as the first argument and the destination directory as the second argument.
			 Here we move superman.txt into superhero/.

		28. nano -->
			$ nano hello.txt

			'nano' is a command line text editor. It works just like a desktop text editor like TextEdit or Notepad, except that it is accessible from the the
			command line and only accepts keyboard input.

		29. PATH -->
			$ echo $PATH

			/home/ccuser/.gem/ruby/2.0.0/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/sbin:/bin
			PATH is an environment variable that stores a list of directories separated by a colon. Each directory contains scripts for the command line to execute.
			PATH lists which directories contain scripts.


		30. rm -->
			$ rm waterboy.txt

			rm deletes files. Here we remove the file waterboy.txt from the file system.

		31. rm -r -->
			$ rm -r comedy
	
			rm -r deletes a directory and all of its child directories.

		32. sed -->
			$ sed 's/snow/rain/' forests.txt

			'sed' stands for “stream editor”. It accepts standard input and modifies it based on an expression, before displaying it as output data.

			In the expression 's/snow/rain/':

			s: stands for “substitution”.
			snow: the search string, the text to find.
			rain: the replacement string, the text to add in place.

		33. sort -->
			$ sort lakes.txt
			sort takes a filename or standard input and orders each line alphabetically, printing it to standard output.

		34. standard error -->
		
			standard error, abbreviated as stderr, is an error message outputted by a failed process.

		35. source -->
			$source ~/.bash_profile
		
			'source' activates the changes in ~/.bash_profile for the current session. Instead of closing the terminal and needing to start a new session, 
			source makes the changes available right away in the session we are in.

		36. standard input -->
			standard input, abbreviated as stdin, is information inputted into the terminal through the keyboard or input device.

		37. standard output -->
			standard output, abbreviated as stdout, is the information outputted after a process is run.